#!/usr/bin/env node

/**
 * Generates HRPC files from schema.json and hrpc.json
 * This regenerates:
 * - generated/hrpc/messages.js (from schema.json via hyperschema)
 * - generated/hrpc/index.js (from src/hrpc/hrpc.json via hrpc compiler)
 * - generated/schema/index.js (from schema.json via hyperschema)
 */

const fs = require('fs')
const path = require('path')
const Hyperschema = require('hyperschema')
const HRPCBuilder = require('hrpc')

const schemaPath = path.join(__dirname, '../schema.json')
const schemaDir = path.join(__dirname, '../generated/schema')
const hrpcMessagesPath = path.join(__dirname, '../generated/hrpc/messages.js')
const hrpcIndexPath = path.join(__dirname, '../generated/hrpc/index.js')
const hrpcJsonPath = path.join(__dirname, '../src/hrpc/hrpc.json')
const hrpcDir = path.dirname(hrpcJsonPath)

// Read schema.json
const schemaData = JSON.parse(fs.readFileSync(schemaPath, 'utf8'))

// Try to load existing schema from directory, or create new one
let schema
try {
  schema = Hyperschema.from(schemaDir)
} catch (err) {
  // If directory doesn't exist or schema can't be loaded, create new
  schema = new Hyperschema()
}

// Get or create namespace
const ns = schema.namespace('wdk-core')

// Process each schema definition
for (const def of schemaData.schema) {
  if (def.enum) {
    // Handle enum - register with enum property
    ns.register({
      name: def.name,
      enum: def.enum.map(e => e.key),
      offset: def.offset !== undefined ? def.offset : 1
    })
  } else if (def.fields) {
    // Handle struct
    ns.register({
      name: def.name,
      compact: def.compact !== undefined ? def.compact : false,
      flagsPosition: def.flagsPosition !== undefined ? def.flagsPosition : 0,
      fields: def.fields.map(field => ({
        name: field.name,
        type: field.type,
        required: field.required !== undefined ? field.required : false
      }))
    })
  }
}

// Ensure output directories exist
const hrpcOutputDir = path.dirname(hrpcMessagesPath)
if (!fs.existsSync(hrpcOutputDir)) {
  fs.mkdirSync(hrpcOutputDir, { recursive: true })
}
if (!fs.existsSync(schemaDir)) {
  fs.mkdirSync(schemaDir, { recursive: true })
}

// Generate schema files
// This will write to generated/schema/index.js and generated/schema/schema.json
Hyperschema.toDisk(schema, { filename: path.join(schemaDir, 'index.js') })

// Also copy the generated file to generated/hrpc/messages.js
// (since both seem to use the same schema)
if (fs.existsSync(path.join(schemaDir, 'index.js'))) {
  const generatedContent = fs.readFileSync(path.join(schemaDir, 'index.js'), 'utf8')
  // Update the comment to indicate it's for hrpc messages
  const updatedContent = generatedContent.replace(
    /\/\/ This file is autogenerated by the hyperschema compiler/,
    '// This file is autogenerated by the hyperschema compiler\n// Used by generated/hrpc/index.js'
  )
  fs.writeFileSync(hrpcMessagesPath, updatedContent)
  console.log('Generated generated/hrpc/messages.js')
}

// Generate HRPC index.js from hrpc.json
try {
  const builder = HRPCBuilder.from(schemaDir, hrpcDir)
  // Generate directly to the output directory
  HRPCBuilder.toDisk(builder, hrpcOutputDir)
  console.log('Generated generated/hrpc/index.js')
} catch (err) {
  console.error('Error generating HRPC index.js:', err.message)
  console.error('Make sure src/hrpc/hrpc.json is valid and schema is generated first')
  process.exit(1)
}

console.log('Schema generation complete!')

