// eslint-disable-next-line no-undef
// Handle unhandled promise rejections and exceptions
if (typeof process !== 'undefined' && process.on) {
  process.on('unhandledRejection', (error) => {
    console.error('Unhandled promise rejection in worklet:', error)
  })
  process.on('uncaughtException', (error) => {
    console.error('Uncaught exception in worklet:', error)
  })
}

// Initialize core dependencies
// eslint-disable-next-line no-undef
const { IPC: BareIPC } = BareKit
const HRPC = require('../generated/hrpc')
const rpcException = require('../src/exceptions/rpc-exception')
const { entropyToMnemonic, mnemonicToSeedSync, mnemonicToEntropy } = require('@scure/bip39')
const { wordlist } = require('@scure/bip39/wordlists/english')
const crypto = require('bare-crypto')

// Load wallet modules from generated file (ensures proper bundling)
// This file is generated by scripts/generate-wallet-modules.js from schema.json
let WDK = null
let walletManagers = {}
let requiredNetworks = []
let wdkLoadError = null

try {
  const walletModules = require('../generated/wallet-modules.js')
  WDK = walletModules.WDK
  walletManagers = walletModules.walletManagers
  requiredNetworks = walletModules.requiredNetworks
  
  console.log('Loaded wallet modules:', Object.keys(walletManagers).join(', '))
} catch (error) {
  wdkLoadError = {
    message: error?.message || String(error),
    stack: error?.stack,
    name: error?.name,
    code: error?.code
  }
  WDK = null
  walletManagers = {}
  requiredNetworks = []
}

// Initialize RPC
const IPC = BareIPC
const rpc = new HRPC(IPC)

// State
let wdk = null

/**
 * Securely zero out sensitive memory (memzero)
 * @param {Buffer|Uint8Array|ArrayBuffer} buffer - Buffer to zero out
 */
const memzero = (buffer) => {
  if (!buffer) return
  
  if (Buffer.isBuffer(buffer)) {
    buffer.fill(0)
  } else if (buffer instanceof Uint8Array) {
    buffer.fill(0)
  } else if (buffer instanceof ArrayBuffer) {
    new Uint8Array(buffer).fill(0)
  } else if (buffer.buffer instanceof ArrayBuffer) {
    // Handle TypedArray views
    new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength).fill(0)
  }
}

// Crypto helper functions
/**
 * Generate a strong encryption key (32 bytes for AES-256)
 * @returns {string} Base64-encoded encryption key
 */
const generateEncryptionKey = () => {
  const key = crypto.randomBytes(32)
  const keyBase64 = key.toString('base64')
  memzero(key)
  return keyBase64
}

/**
 * Encrypt data using AES-256-GCM
 * @param {Uint8Array|Buffer} data - Data to encrypt
 * @param {string} keyBase64 - Base64-encoded encryption key
 * @returns {string} Base64-encoded encrypted data with IV and auth tag
 */
const encrypt = (data, keyBase64) => {
  const key = Buffer.from(keyBase64, 'base64')
  const iv = crypto.randomBytes(12) // 96-bit IV for GCM
  
  // Convert data to Buffer if needed
  const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data)
  
  // Use AES-256-GCM for authenticated encryption
  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv)
  const encrypted = Buffer.concat([cipher.update(dataBuffer), cipher.final()])
  const authTag = cipher.getAuthTag()
  
  // Combine IV + encrypted data + auth tag
  const result = Buffer.concat([iv, encrypted, authTag])
  const resultBase64 = result.toString('base64')
  
  // Zero out sensitive buffers (caller should zero input data buffer)
  memzero(key)
  memzero(iv)
  memzero(encrypted)
  memzero(authTag)
  
  return resultBase64
}

/**
 * Decrypt data using AES-256-GCM
 * @param {string} encryptedBase64 - Base64-encoded encrypted data with IV and auth tag
 * @param {string} keyBase64 - Base64-encoded encryption key
 * @returns {Buffer} Decrypted data
 */
const decrypt = (encryptedBase64, keyBase64) => {
  const key = Buffer.from(keyBase64, 'base64')
  const encryptedBuffer = Buffer.from(encryptedBase64, 'base64')
  
  // Extract IV (12 bytes), encrypted data, and auth tag (16 bytes)
  const iv = encryptedBuffer.subarray(0, 12)
  const authTag = encryptedBuffer.subarray(encryptedBuffer.length - 16)
  const encrypted = encryptedBuffer.subarray(12, encryptedBuffer.length - 16)
  
  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv)
  decipher.setAuthTag(authTag)
  
  const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()])
  
  // Zero out sensitive buffers (but not the decrypted result we're returning)
  memzero(key)
  memzero(encryptedBuffer)
  memzero(iv)
  memzero(authTag)
  memzero(encrypted)
  
  return decrypted
}

/**
 * Generate entropy for a seed phrase
 * @param {number} wordCount - Number of words (12 or 24)
 * @returns {Uint8Array} Entropy bytes
 */
const generateEntropy = (wordCount) => {
  if (wordCount !== 12 && wordCount !== 24) {
    throw new Error('Word count must be 12 or 24')
  }
  // 12 words = 128 bits, 24 words = 256 bits
  const entropyLength = wordCount === 12 ? 16 : 32
  const entropyBuffer = crypto.randomBytes(entropyLength)
  // Create a new Uint8Array and copy bytes explicitly for @scure/bip39 compatibility
  const entropy = new Uint8Array(entropyLength)
  entropy.set(entropyBuffer)
  // Zero out the original buffer
  memzero(entropyBuffer)
  return entropy
}

/**
 * Encrypt seed and entropy with a new encryption key
 * @param {Uint8Array|Buffer} seed - Seed bytes to encrypt
 * @param {Uint8Array|Buffer} entropy - Entropy bytes to encrypt
 * @returns {Object} Object containing encryptionKey, encryptedSeedBuffer, and encryptedEntropyBuffer
 */
const encryptSecrets = (seed, entropy) => {
  // Generate encryption key
  const encryptionKey = generateEncryptionKey()
  
  // Convert to buffers if needed
  const seedBuffer = Buffer.isBuffer(seed) ? seed : Buffer.from(seed)
  const entropyBuffer = Buffer.isBuffer(entropy) ? entropy : Buffer.from(entropy)
  
  // Encrypt both secrets
  const encryptedSeedBuffer = encrypt(seedBuffer, encryptionKey)
  const encryptedEntropyBuffer = encrypt(entropyBuffer, encryptionKey)
  
  // Zero out sensitive buffers
  memzero(seedBuffer)
  memzero(entropyBuffer)
  
  return {
    encryptionKey,
    encryptedSeedBuffer,
    encryptedEntropyBuffer
  }
}

// Helper functions
const withErrorHandling = (handler) => {
  return async (...args) => {
    try {
      return await handler(...args)
    } catch (error) {
      throw new Error(rpcException.stringifyError(error))
    }
  }
}

/**
 * Generalized function to call any WDK account method
 * This provides a dev-friendly way to call account methods without needing individual handlers
 * 
 * @param {string} methodName - The method name to call on the account (e.g., 'getAddress', 'getBalance')
 * @param {string} network - Network name (e.g., 'ethereum', 'spark')
 * @param {number} accountIndex - Account index
 * @param {any} args - Arguments to pass to the method
 * @param {object} options - Optional configuration
 * @param {function} options.transformResult - Optional function to transform the result
 * @param {any} options.defaultValue - Default value to return if method doesn't exist
 * @returns {Promise<any>} The result from the account method
 */
const callWdkMethod = async (methodName, network, accountIndex, args = null, options = {}) => {
  if (!wdk) {
    throw new Error('WDK not initialized. Call initializeWDK first.')
  }
  
  const account = await wdk.getAccount(network, accountIndex)
  
  if (typeof account[methodName] !== 'function') {
    if (options.defaultValue !== undefined) {
      console.warn(`${methodName} not available for network: ${network}, returning default value`)
      return options.defaultValue
    }
    const availableMethods = Object.keys(account)
      .filter(key => typeof account[key] === 'function')
      .join(', ')
    throw new Error(
      `Method "${methodName}" not found on account for network "${network}". ` +
      `Available methods: ${availableMethods}`
    )
  }
  
  const result = await account[methodName](args)
  
  if (options.transformResult) {
    return options.transformResult(result)
  }
  
  return result
}

// RPC Handlers
rpc.onWorkletStart(withErrorHandling(async (init) => {
  // workletStart no longer initializes WDK - that's done via initializeWDK
  return { status: 'started' }
}))

/**
 * Generate entropy and encrypt seed buffer and entropy
 */
rpc.onGenerateEntropyAndEncrypt(withErrorHandling(async (request) => {
  const { wordCount } = request
  
  if (wordCount !== 12 && wordCount !== 24) {
    throw new Error('Word count must be 12 or 24')
  }
  
  // Generate entropy
  const entropy = generateEntropy(wordCount)
  
  // Generate mnemonic from entropy
  const mnemonic = entropyToMnemonic(entropy, wordlist)
  
  // Generate seed buffer from mnemonic (this is what WDK uses)
  // The seed is typically derived from the mnemonic using PBKDF2
  // For now, we'll use the mnemonic itself as the seed phrase
  const seedBuffer = Buffer.from(mnemonic, 'utf8')
  
  // Generate encryption key
  const encryptionKey = generateEncryptionKey()
  
  // Encrypt seed buffer and entropy
  const encryptedSeedBuffer = encrypt(seedBuffer, encryptionKey)
  const entropyBuffer = Buffer.from(entropy)
  const encryptedEntropyBuffer = encrypt(entropyBuffer, encryptionKey)
  
  // Zero out sensitive buffers
  memzero(entropy)
  memzero(seedBuffer)
  memzero(entropyBuffer)
  
  return {
    encryptionKey,
    encryptedSeedBuffer,
    encryptedEntropyBuffer
  }
}))

/**
 * Get mnemonic phrase from encrypted entropy
 */
rpc.onGetMnemonicFromEntropy(withErrorHandling(async (request) => {
  const { encryptedEntropy, encryptionKey } = request
  
  // Decrypt entropy
  const entropyBuffer = decrypt(encryptedEntropy, encryptionKey)
  // Create a new Uint8Array and copy bytes explicitly for @scure/bip39 compatibility
  const entropy = new Uint8Array(entropyBuffer.length)
  entropy.set(entropyBuffer)
  
  // Convert entropy to mnemonic
  const mnemonic = entropyToMnemonic(wordlist, entropy)
  
  // Zero out sensitive buffers
  memzero(entropyBuffer)
  memzero(entropy)
  
  return { mnemonic }
}))

/**
 * RPC handler: Convert mnemonic phrase to encrypted seed and entropy
 * 
 * Takes a BIP39 mnemonic phrase and derives both the seed (used by WDK) 
 * and entropy (original random bytes), then encrypts both for secure storage.
 * 
 * @param {Object} request - The RPC request object
 * @param {string} request.mnemonic - BIP39 mnemonic phrase (12 or 24 words)
 * @returns {Promise<Object>} Encrypted seed and entropy with encryption key
 */
rpc.onGetSeedAndEntropyFromMnemonic(withErrorHandling(async (request) => {
  const { mnemonic } = request
  
  // Validate mnemonic input
  if (!mnemonic || typeof mnemonic !== 'string') {
    throw new Error('Mnemonic phrase must be a non-empty string')
  }
  
  // Derive seed from mnemonic (used by WDK for wallet operations)
  const seed = mnemonicToSeedSync(mnemonic)
  // Extract entropy from mnemonic (original random bytes used to generate mnemonic)
  const entropy = mnemonicToEntropy(mnemonic, wordlist)

  // Encrypt both secrets and return with the encryption key
  return encryptSecrets(seed, entropy)
}))

/**
 * Initialize WDK with either seedPhrase or encryptionKey + encryptedSeed
 */
rpc.onInitializeWDK(withErrorHandling(async (init) => {
  if (!WDK) {
    const errorMsg = wdkLoadError
      ? `WDK failed to load: ${wdkLoadError.message}\nStack: ${wdkLoadError.stack || 'No stack trace'}`
      : 'WDK not loaded - unknown error during initialization'
    throw new Error(errorMsg)
  }
  
  if (wdk) {
    console.log('Disposing existing WDK instance...')
    wdk.dispose()
  }
  
  const networkConfigs = JSON.parse(init.config || '{}')
  const missingNetworks = requiredNetworks.filter(network => !networkConfigs[network])
  
  if (missingNetworks.length > 0) {
    throw new Error(`Missing network configurations: ${missingNetworks.join(', ')}`)
  }
  
  let seedPhrase
  
  if (init.seedPhrase) {
    // Initialize from seed phrase directly
    console.log('Initializing WDK with seed phrase')
    seedPhrase = init.seedPhrase
  } else if (init.encryptionKey && init.encryptedSeed) {
    // Initialize from encrypted seed
    console.log('Initializing WDK with encrypted seed')
    const decryptedSeedBuffer = decrypt(init.encryptedSeed, init.encryptionKey)
    seedPhrase = decryptedSeedBuffer.toString('utf8')
    // Zero out the decrypted buffer after extracting the seed phrase
    memzero(decryptedSeedBuffer)
  } else {
    throw new Error('Either seedPhrase or (encryptionKey + encryptedSeed) must be provided')
  }
  
  wdk = new WDK(seedPhrase)
  
  for (const [networkName, config] of Object.entries(networkConfigs)) {
    if (config && typeof config === 'object') {
      const walletManager = walletManagers[networkName]
      
      if (!walletManager) {
        throw new Error(`No wallet manager found for network: ${networkName}`)
      }
      
      console.log(`Registering ${networkName} wallet`)
      wdk.registerWallet(networkName, walletManager, config)
    }
  }
  
  console.log('WDK initialization complete')
  return { status: 'initialized' }
}))

/**
 * Generic handler for all WDK account methods
 * This single handler can call any method on any WDK account dynamically
 * No special handling - just calls the method and returns the raw result
 */
rpc.onCallMethod(withErrorHandling(async (payload) => {
  const { methodName, network, accountIndex, args: argsJson } = payload
  
  // Parse args if provided (JSON string)
  const args = argsJson ? JSON.parse(argsJson) : null
  
  // Call the method directly - no special handling
  const result = await callWdkMethod(
    methodName,
    network,
    accountIndex,
    args
  )
  
  // Return as JSON string (raw result, no transformation)
  return { result: JSON.stringify(result) }
}))

rpc.onDispose(withErrorHandling(() => {
  if (wdk) {
    wdk.dispose()
    wdk = null
  }
}))
